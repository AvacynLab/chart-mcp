"""Backtest service executing trading strategies over historical OHLCV data."""

from __future__ import annotations

from dataclasses import dataclass
from math import sqrt
from typing import Iterable, List

import numpy as np
import pandas as pd

from chart_mcp.schemas.backtest import StrategySpec
from chart_mcp.services.data_providers.base import MarketDataProvider
from chart_mcp.utils.errors import BadRequest
from chart_mcp.utils.timeframes import parse_timeframe


@dataclass(frozen=True)
class Trade:
    """Represents a single completed trade in the simulation."""

    entry_ts: int
    exit_ts: int
    entry_price: float
    exit_price: float
    return_pct: float


@dataclass(frozen=True)
class BacktestMetrics:
    """Aggregate metrics summarizing a backtest run."""

    total_return: float
    cagr: float
    max_drawdown: float
    win_rate: float
    sharpe: float
    profit_factor: float


@dataclass(frozen=True)
class BacktestResult:
    """Complete output of a backtest run."""

    metrics: BacktestMetrics
    equity_curve: list[tuple[int, float]]
    trades: List[Trade]


@dataclass(frozen=True)
class SmaCrossStrategy:
    """Simple moving-average crossover strategy specification."""

    fast_window: int
    slow_window: int


class BacktestEngine:
    """Numerical engine computing trading signals and derived metrics."""

    def run(
        self,
        frame: pd.DataFrame,
        strategy: SmaCrossStrategy,
        *,
        timeframe: str,
        fees_bps: float,
        slippage_bps: float,
    ) -> BacktestResult:
        """Simulate the configured strategy on the provided OHLCV frame."""
        if frame.empty or "c" not in frame:
            return self._empty_result()

        closes = frame["c"].astype(float)
        fast_ma = closes.rolling(
            window=strategy.fast_window, min_periods=strategy.fast_window
        ).mean()
        slow_ma = closes.rolling(
            window=strategy.slow_window, min_periods=strategy.slow_window
        ).mean()

        # Positions are considered valid only when both moving averages are defined to
        # avoid artificial trades generated by partial windows.
        mask = fast_ma.notna() & slow_ma.notna()
        bullish = ((fast_ma > slow_ma) & mask).astype(int)
        signals = bullish.diff().fillna(0).astype(int)

        entries = frame.index[signals == 1].tolist()
        exits = frame.index[signals == -1].tolist()

        # If we finish in a long position without an explicit exit signal, close at
        # the final candle so metrics reflect an actual realized trade.
        if entries and (not exits or entries[-1] > exits[-1]):
            exits.append(frame.index[-1])

        trades = self._build_trades(frame, entries, exits, fees_bps, slippage_bps)
        equity_curve = self._equity_curve(trades)
        metrics = self._compute_metrics(
            trades,
            equity_curve,
            timeframe_seconds=parse_timeframe(timeframe),
            period_seconds=self._period_seconds(frame),
        )
        return BacktestResult(metrics=metrics, equity_curve=equity_curve, trades=trades)

    def _build_trades(
        self,
        frame: pd.DataFrame,
        entries: List[int],
        exits: List[int],
        fees_bps: float,
        slippage_bps: float,
    ) -> List[Trade]:
        """Convert entry/exit indices into normalized trade structures."""
        trades: List[Trade] = []
        exit_iter = iter(exits)
        current_exit = next(exit_iter, None)
        fee_rate = fees_bps / 10_000
        slippage_rate = slippage_bps / 10_000

        for entry_idx in entries:
            while current_exit is not None and current_exit < entry_idx:
                current_exit = next(exit_iter, None)
            if current_exit is None:
                break

            entry_row = frame.loc[entry_idx]
            exit_row = frame.loc[current_exit]
            entry_price = float(entry_row["c"]) * (1 + slippage_rate)
            exit_price = float(exit_row["c"]) * (1 - slippage_rate)
            # Fees are charged both on entry and exit. We model them as a reduction
            # in the effective proceeds of the trade.
            entry_cost = entry_price * (1 + fee_rate)
            exit_proceeds = exit_price * (1 - fee_rate)
            if entry_cost <= 0:
                continue
            trade_return = (exit_proceeds - entry_cost) / entry_cost
            trades.append(
                Trade(
                    entry_ts=int(entry_row["ts"]),
                    exit_ts=int(exit_row["ts"]),
                    entry_price=round(entry_cost, 8),
                    exit_price=round(exit_proceeds, 8),
                    return_pct=round(trade_return, 6),
                )
            )
            current_exit = next(exit_iter, None)

        return trades

    @staticmethod
    def _equity_curve(trades: Iterable[Trade]) -> list[tuple[int, float]]:
        """Compute the cumulative equity curve from sequential trades."""
        equity_points: list[tuple[int, float]] = []
        equity = 1.0
        for trade in trades:
            equity *= 1 + trade.return_pct
            equity_points.append((trade.exit_ts, round(equity, 6)))
        return equity_points

    @staticmethod
    def _period_seconds(frame: pd.DataFrame) -> int:
        """Duration between first and last candle in seconds."""
        if frame.empty:
            return 0
        start_ts = int(frame.iloc[0]["ts"])
        end_ts = int(frame.iloc[-1]["ts"])
        return max(end_ts - start_ts, 0)

    @staticmethod
    def _empty_result() -> BacktestResult:
        """Return a neutral result when the simulation cannot run."""
        metrics = BacktestMetrics(
            total_return=0.0,
            cagr=0.0,
            max_drawdown=0.0,
            win_rate=0.0,
            sharpe=0.0,
            profit_factor=0.0,
        )
        return BacktestResult(metrics=metrics, equity_curve=[], trades=[])

    def _compute_metrics(
        self,
        trades: List[Trade],
        equity_curve: list[tuple[int, float]],
        *,
        timeframe_seconds: int,
        period_seconds: int,
    ) -> BacktestMetrics:
        """Derive aggregated metrics from the executed trades."""
        if not trades:
            return self._empty_result().metrics

        returns = np.array([trade.return_pct for trade in trades], dtype=float)
        total_return = float(np.prod(1 + returns) - 1)
        wins = returns[returns > 0]
        losses = returns[returns < 0]
        win_rate = float(len(wins) / len(returns)) if len(returns) else 0.0
        profit_factor = (
            float(wins.sum() / abs(losses.sum())) if losses.sum() != 0 else float(wins.sum())
        )

        # The Sharpe ratio is computed with trade returns as the periodic returns.
        std_dev = float(np.std(returns, ddof=1)) if len(returns) > 1 else 0.0
        sharpe = float((returns.mean() / std_dev) * sqrt(len(returns))) if std_dev > 0 else 0.0

        cagr = 0.0
        if period_seconds > 0:
            years = period_seconds / (365 * 24 * 3600)
            if years > 0:
                cagr = float((1 + total_return) ** (1 / years) - 1)

        max_drawdown = self._max_drawdown(equity_curve)
        return BacktestMetrics(
            total_return=round(total_return, 6),
            cagr=round(cagr, 6),
            max_drawdown=round(max_drawdown, 6),
            win_rate=round(win_rate, 6),
            sharpe=round(sharpe, 6),
            profit_factor=round(profit_factor, 6),
        )

    @staticmethod
    def _max_drawdown(equity_curve: list[tuple[int, float]]) -> float:
        """Compute the maximum drawdown from the equity curve."""
        if not equity_curve:
            return 0.0
        peaks: list[float] = []
        max_drawdown = 0.0
        for _, equity in equity_curve:
            peaks.append(equity if not peaks else max(peaks[-1], equity))
            drawdown = (equity - peaks[-1]) / peaks[-1]
            max_drawdown = min(max_drawdown, drawdown)
        return abs(max_drawdown)


class BacktestService:
    """High-level service fetching data and delegating to the engine."""

    def __init__(self, engine: BacktestEngine | None = None) -> None:
        self.engine = engine or BacktestEngine()

    def run(
        self,
        provider: MarketDataProvider,
        *,
        symbol: str,
        timeframe: str,
        start: int | None,
        end: int | None,
        limit: int,
        fees_bps: float,
        slippage_bps: float,
        strategy: StrategySpec,
    ) -> BacktestResult:
        """Fetch historical candles and execute the selected backtest."""
        if strategy.name != "sma_cross":
            raise BadRequest("Unsupported strategy requested")

        slow_window = strategy.params.slow_window
        lookback = max(limit, slow_window * 5)
        frame = provider.get_ohlcv(
            symbol,
            timeframe,
            limit=lookback,
            start=start,
            end=end,
        )
        if frame.empty:
            raise BadRequest("No market data available for the requested range")

        spec = SmaCrossStrategy(
            fast_window=strategy.params.fast_window,
            slow_window=strategy.params.slow_window,
        )
        return self.engine.run(
            frame,
            spec,
            timeframe=timeframe,
            fees_bps=fees_bps,
            slippage_bps=slippage_bps,
        )


__all__ = [
    "BacktestEngine",
    "BacktestMetrics",
    "BacktestResult",
    "BacktestService",
    "SmaCrossStrategy",
    "Trade",
]
